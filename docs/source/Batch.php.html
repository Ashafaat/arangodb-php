<html>
    <head>
        <script
            type="text/javascript"
            src="../js/jquery-1.4.2.min.js">
        </script>
        <script
            type="text/javascript"
            src="../syntax_highlighter/scripts/shCore.js">
        </script>
        <script
            type="text/javascript"
            src="../syntax_highlighter/scripts/shBrushJScript.js">
        </script>
        <script
            type="text/javascript"
            src="../syntax_highlighter/scripts/shBrushPhp.js">
        </script>
        <script
            type="text/javascript"
            src="../syntax_highlighter/scripts/shBrushXml.js">
        </script>
        <link
            href="../syntax_highlighter/styles/shCore.css" rel="stylesheet"
            type="text/css"
        />
        <link
            href="../syntax_highlighter/styles/shCoreEclipse.css"
            rel="stylesheet" type="text/css"
        />
        <link
            href="../syntax_highlighter/styles/shThemeWordpress.css"
            rel="stylesheet" type="text/css"
        />
    </head>
    <body>
        <pre class="brush: php">&lt;?php

/**
 * ArangoDB PHP client: batch
 *
 * @package triagens\ArangoDb
 * @author  Frank Mayer
 * @since   1.1
 *
 */

namespace triagens\ArangoDb;

/**
 * Provides batching functionality
 *
 * @package triagens\ArangoDb
 * @example ArangoDb/examples/batch.php
 *
 */


class Batch
{
    /**
     * Batch Response Object
     *
     * @var HttpResponse $_batchResponse
     */
    public $_batchResponse;


    /**
     * Flag that signals if this batch was processed or not. Processed =&gt; true ,or not processed =&gt; false
     *
     * @var boolean $_processed
     */
    private $_processed = false;


    /**
     * The array of BatchPart objects
     *
     * @var array $_batchParts
     */
    private $_batchParts = array();


    /**
     * The array of BatchPart objects
     *
     * @var array $_batchParts
     */
    private $_nextBatchPartId = null;


    /**
     * An array of BatchPartCursor options
     *
     * @var array $_batchParts
     */
    private $_batchPartCursorOptions = array();


    /**
     * The connection object
     *
     * @var Connection $_connection
     */
    private $_connection = null;

    /**
     * The sanitize default value
     *
     * @var object $_sanitize
     */
    private $_sanitize = false;


    /**
     * Constructor for Batch instance. Batch instance by default starts capturing request after initiated.
     * To disable this, pass startCapture=&gt;false inside the options array parameter
     *
     * @param Connection $connection that this batch class will monitor for requests in order to batch them. Connection parameter is mandatory.
     * @param array      $options    An array of options for Batch construction. See below for options:
     *
     * &lt;p&gt;Options are :
     * &lt;li&gt;'_sanitize' - True to remove _id and _rev attributes from result documents returned from this batch. Defaults to false.&lt;/li&gt;
     * &lt;li&gt;'$startCapture' - Start batch capturing immediately after batch instantiation. Defaults to true.
     * &lt;/li&gt;
     * &lt;/p&gt;
     *
     * @return Batch
     */
    public function __construct(Connection $connection, $options = array())
    {
        $startCapture = true;
        $sanitize     = false;
        $options      = array_merge($options, $this-&gt;getCursorOptions($sanitize));
        extract($options, EXTR_IF_EXISTS);
        $this-&gt;_sanitize = $sanitize;

        $this-&gt;setConnection($connection);

        // set default cursor options. Sanitize is currently the only local one.
        $this-&gt;_batchPartCursorOptions = array(Cursor::ENTRY_SANITIZE =&gt; (bool) $this-&gt;_sanitize);

        if ($startCapture === true) {
            $this-&gt;startCapture();
        }

        return $this;
    }


    /**
     * Sets the connection for he current batch. (mostly internal function)
     *
     * @param Connection $connection
     *
     * @return Batch
     */
    public function setConnection($connection)
    {
        $this-&gt;_connection = $connection;

        return $this;
    }


    /**
     * Start capturing requests. To stop capturing, use stopCapture()
     *
     * see triagens\ArangoDb\Batch::stopCapture()
     *
     * @param array $options
     *
     * @return Batch
     *
     */
    public function startCapture($options = array())
    {
        $this-&gt;activate($options);

        return $this;
    }


    /**
     * Stop capturing requests. If the batch has not been processed yet, more requests can be appended by calling startCapture() again.
     *
     * see Batch::startCapture()
     *
     * @throws ClientException
     * @return Batch
     */
    public function stopCapture()
    {
        // check if this batch is the active one... and capturing. Ignore, if we're not capturing...
        if ($this-&gt;isActive()) {
            $this-&gt;setCapture(false);

            return $this;
        } else {
            throw new ClientException('Cannot stop capturing with this batch. Batch is not active...');
        }
    }


    /**
     * Returns true, if this batch is active in its associated connection.
     *
     * @return bool
     */
    public function isActive()
    {
        $activeBatch = $this-&gt;getActive($this-&gt;_connection);
        $result      = $activeBatch === $this ? true : false;

        return $result;
    }


    /**
     * Returns true, if this batch is capturing requests.
     *
     * @return bool
     */
    public function isCapturing()
    {
        return $this-&gt;getConnectionCaptureMode($this-&gt;_connection);
    }


    /**
     * Activates the batch. This sets the batch active in its associated connection and also starts capturing.
     *
     * @return object $this
     */
    public function activate()
    {
        $this-&gt;setActive($this);
        $this-&gt;setCapture(true);

        return $this;
    }


    /**
     * Sets the batch active in its associated connection.
     *
     * @return object $this
     */
    public function setActive()
    {
        $this-&gt;_connection-&gt;setActiveBatch($this);

        return $this;
    }


    /**
     * Sets the batch's associated connection into capture mode.
     *
     * @param boolean $state
     *
     * @return object $this
     */
    public function setCapture($state)
    {
        $this-&gt;_connection-&gt;setCaptureBatch($state);

        return $this;
    }


    /**
     * Gets active batch in given connection.
     *
     * @param Connection $connection
     *
     * @return $this
     */
    public function getActive($connection)
    {
        $connection-&gt;getActiveBatch();

        return $this;
    }


    /**
     * Returns true, if given connection is in batch-capture mode.
     *
     * @param Connection $connection
     *
     * @return bool
     */
    public function getConnectionCaptureMode($connection)
    {
        return $connection-&gt;isInBatchCaptureMode();
    }


    /**
     * Sets connection into Batch-Request mode. This is necessary to distinguish between normal and the batch request.
     *
     * @param boolean $state
     *
     * @return $this
     */
    private function setBatchRequest($state)
    {
        $this-&gt;_connection-&gt;setBatchRequest($state);
        $this-&gt;_processed = true;

        return $this;
    }


    /**
     * Sets the id of the next batch-part. The id can later be used to retrieve the batch-part.
     *
     * @param mixed $batchPartId
     *
     * @return Batch
     */
    public function nextBatchPartId($batchPartId)
    {
        $this-&gt;_nextBatchPartId = $batchPartId;

        return $this;
    }


    /**
     * Set client side cursor options (for example: sanitize) for the next batch part.
     *
     * @param mixed $batchPartCursorOptions
     *
     * @return Batch
     */
    public function nextBatchPartCursorOptions($batchPartCursorOptions)
    {
        $this-&gt;_batchPartCursorOptions = $batchPartCursorOptions;

        return $this;
    }


    /**
     * Append the request to the batch-part
     *
     * @param mixed $method  - The method of the request (GET, POST...)
     * @param mixed $request - The request that will get appended to the batch
     *
     * @return HttpResponse
     */
    public function append($method, $request)
    {
        preg_match('%/_api/simple/(?P&lt;simple&gt;\w*)|/_api/(?P&lt;direct&gt;\w*)%ix', $request, $regs);

        $type = $regs['direct'] != '' ? $regs['direct'] : $regs['simple'];

        if ($type == $regs['direct'] &amp;&amp; $method == 'GET') {
            $type = 'get' . $type;
        }

        $result = 'HTTP/1.1 202 Accepted' . HttpHelper::EOL;
        $result .= 'location: /_api/document/0/0' . HttpHelper::EOL;
        $result .= 'server: triagens GmbH High-Performance HTTP Server' . HttpHelper::EOL;
        $result .= 'content-type: application/json; charset=utf-8' . HttpHelper::EOL;
        $result .= 'etag: &quot;0&quot;' . HttpHelper::EOL;
        $result .= 'connection: Close' . HttpHelper::EOL . HttpHelper::EOL;
        $result .= '{&quot;error&quot;:false,&quot;_id&quot;:&quot;0/0&quot;,&quot;id&quot;:&quot;0&quot;,&quot;_rev&quot;:0,&quot;hasMore&quot;:1, &quot;result&quot;:[{}], &quot;documents&quot;:[{}]}' . HttpHelper::EOL . HttpHelper::EOL;

        $response  = new HttpResponse($result);
        $batchPart = new BatchPart($this, $this-&gt;_nextBatchPartId, $type, $request, $response, array(&quot;cursorOptions&quot; =&gt; $this-&gt;_batchPartCursorOptions));
        if (is_null($this-&gt;_nextBatchPartId)) {
            $nextNumeric                     = count($this-&gt;_batchParts);
            $this-&gt;_batchParts[$nextNumeric] = $batchPart;
        } else {
            $this-&gt;_batchParts[$this-&gt;_nextBatchPartId] = $batchPart;
            $this-&gt;_nextBatchPartId                     = null;
        }

        return $response;
    }


    /**
     * Split batch request and use ContentId as array key
     *
     * @param mixed $pattern
     * @param mixed $string
     *
     * @return array $array - Array of batch-parts
     */
    public function splitWithContentIdKey($pattern, $string)
    {
        $array    = array();
        $exploded = explode($pattern, $string);
        foreach ($exploded as $key =&gt; $value) {
            $response  = new HttpResponse($value);
            $contentId = $response-&gt;getHeader('Content-Id');

            if (!is_null($contentId)) {
                $array[$contentId] = $value;
            } else {
                $array[$key] = $value;
            }
        }

        return $array;
    }


    /**
     * Processes this batch. This sends the captured requests to the server as one batch.
     *
     * @throws ClientException
     * @return bool - true if processing of the batch was  or the HttpResponse object in case of a failure. A successful process just means that tha parts were processed. Each part has it's own response though and should be checked on its own.
     */
    public function process()
    {
        $this-&gt;stopCapture();
        $this-&gt;setBatchRequest(true);
        $data       = '';
        $batchParts = $this-&gt;getBatchParts();

        if (count($batchParts) == 0) {
            throw new ClientException('Can\'t process empty batch.');
        }

        /** @var $partValue BatchPart */
        foreach ($batchParts as $partValue) {
            $data .= '--' . HttpHelper::MIME_BOUNDARY . HttpHelper::EOL;
            $data .= 'Content-Type: application/x-arango-batchpart' . HttpHelper::EOL;

            if (!is_null($partValue-&gt;getId())) {
                $data .= 'Content-Id: ' . (string) $partValue-&gt;getId() . HttpHelper::EOL . HttpHelper::EOL;
            } else {
                $data .= HttpHelper::EOL;
            }

            $data .= (string) $partValue-&gt;getRequest() . HttpHelper::EOL;
        }
        $data .= '--' . HttpHelper::MIME_BOUNDARY . '--' . HttpHelper::EOL . HttpHelper::EOL;

        $params               = array();
        $url                  = UrlHelper::appendParamsUrl(Urls::URL_BATCH, $params);
        $this-&gt;_batchResponse = $this-&gt;_connection-&gt;post($url, ($data));
        if ($this-&gt;_batchResponse-&gt;getHttpCode() !== 200) {
            return $this-&gt;_batchResponse;
        }
        $body       = $this-&gt;_batchResponse-&gt;getBody();
        $body       = trim($body, '--' . HttpHelper::MIME_BOUNDARY . '--');
        $batchParts = $this-&gt;splitWithContentIdKey('--' . HttpHelper::MIME_BOUNDARY . HttpHelper::EOL, $body);

        foreach ($batchParts as $partKey =&gt; $partValue) {
            $response                     = new HttpResponse($partValue);
            $body                         = $response-&gt;getBody();
            $response                     = new HttpResponse($body);
            $batchPartResponses[$partKey] = $response;
            $this-&gt;getPart($partKey)-&gt;setResponse($batchPartResponses[$partKey]);
        }

        return $this;
    }


    /**
     * Get the total count of the batch parts
     *
     * @return integer $count
     */
    public function countParts()
    {
        $count = count($this-&gt;_batchParts);

        return $count;
    }


    /**
     * Get the batch part identified by the array key (0...n) or its id (if it was set with nextBatchPartId($id) )
     *
     * @param mixed $partId the batch part id. Either it's numeric key or a given name.
     *
     * @throws ClientException
     * @return mixed $batchPart
     */
    public function getPart($partId)
    {
        if (!isset($this-&gt;_batchParts[$partId])) {
            throw new ClientException('Request batch part does not exist.');
        }

        $batchPart = $this-&gt;_batchParts[$partId];

        return $batchPart;
    }


    /**
     * Get the batch part identified by the array key (0...n) or its id (if it was set with nextBatchPartId($id) )
     *
     * @param mixed $partId the batch part id. Either it's numeric key or a given name.
     *
     * @return mixed $partId
     */
    public function getPartResponse($partId)
    {
        $batchPart = $this-&gt;getPart($partId)-&gt;getResponse();

        return $batchPart;
    }


    /**
     * Get the batch part identified by the array key (0...n) or its id (if it was set with nextBatchPartId($id) )
     *
     * @param mixed $partId the batch part id. Either it's numeric key or a given name.
     *
     * @return mixed $partId
     */
    public function getProcessedPartResponse($partId)
    {
        $response = $this-&gt;getPart($partId)-&gt;getProcessedResponse();

        return $response;
    }


    /**
     * Returns the array of batch-parts
     *
     * @return array $_batchParts
     */
    public function getBatchParts()
    {
        return $this-&gt;_batchParts;
    }


    /**
     * Return an array of cursor options
     *
     * @return array - array of options
     */
    private function getCursorOptions()
    {
        return $this-&gt;_batchPartCursorOptions;
    }


    /**
     * Return this batch's connection
     *
     * @return Connection
     */
    public function getConnection()
    {
        return $this-&gt;_connection;
    }
}
</pre>
        <script type="text/javascript">
             SyntaxHighlighter.all()
             jQuery('.gutter div').each(function(key, data){
                jQuery(data).prepend('<a name="L'+jQuery(data).text()+'"/>');
             });
        </script>
    </body>
</html>